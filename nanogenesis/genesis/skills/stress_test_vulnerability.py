import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))
from genesis.core.base import Tool

import asyncio
import aiohttp
import time
import sys
from typing import List, Dict, Any

class StressTestVulnerabilityTool(Tool):
    @property
    def name(self) -> str:
        return "stress_test_vulnerability"
    
    @property
    def description(self) -> str:
        return "执行针对常见漏洞（如慢速HTTP攻击、资源耗尽）的自动化压测。生成流量、监控响应，并输出证据报告。"
    
    @property
    def parameters(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "target_url": {"type": "string", "description": "目标URL（例如 http://example.com）"},
                "test_duration": {"type": "integer", "description": "测试持续时间（秒）", "default": 30},
                "concurrent_connections": {"type": "integer", "description": "并发连接数", "default": 50},
                "attack_type": {"type": "string", "description": "攻击类型：'slowloris'（慢速头）或 'resource_drain'（资源耗尽）", "default": "slowloris"}
            },
            "required": ["target_url"]
        }
    
    async def execute(self, target_url: str, test_duration: int = 30, concurrent_connections: int = 50, attack_type: str = "slowloris") -> str:
        """
        执行压测并返回结果摘要。
        注意：此脚本仅为教育目的和授权测试设计。
        """
        start_time = time.time()
        results = {
            "target": target_url,
            "attack_type": attack_type,
            "duration": test_duration,
            "concurrency": concurrent_connections,
            "requests_sent": 0,
            "successful_responses": 0,
            "failed_responses": 0,
            "timeouts": 0,
            "average_response_time": 0.0,
            "evidence_log": []
        }
        
        if attack_type == "slowloris":
            result_text = await self._slowloris_attack(target_url, test_duration, concurrent_connections, results)
        elif attack_type == "resource_drain":
            result_text = await self._resource_drain_attack(target_url, test_duration, concurrent_connections, results)
        else:
            return f"错误：不支持的攻击类型 '{attack_type}'。支持的类型：'slowloris', 'resource_drain'"
        
        # 计算总结
        total_requests = results['requests_sent']
        if total_requests > 0:
            success_rate = (results['successful_responses'] / total_requests) * 100
        else:
            success_rate = 0
        
        summary = f"""
=== 漏洞压测执行完成 ===
目标: {target_url}
攻击类型: {attack_type}
持续时间: {test_duration} 秒
并发连接: {concurrent_connections}
总请求数: {total_requests}
成功响应: {results['successful_responses']}
失败响应: {results['failed_responses']}
超时: {results['timeouts']}
成功率: {success_rate:.2f}%
平均响应时间: {results['average_response_time']:.2f} 秒
        
关键发现:
"""
        # 基于结果生成漏洞存在性推断
        if attack_type == "slowloris" and results['timeouts'] > concurrent_connections * 0.5:
            summary += "- ✅ 检测到潜在慢速HTTP攻击漏洞：服务器在保持大量慢速连接时表现出拒绝服务倾向。\n"
            summary += f"  证据：在 {concurrent_connections} 个并发连接中，{results['timeouts']} 个连接超时。\n"
        elif attack_type == "resource_drain" and results['average_response_time'] > 5.0:
            summary += "- ✅ 检测到潜在资源耗尽漏洞：在高并发请求下，服务器响应时间显著下降。\n"
            summary += f"  证据：平均响应时间达到 {results['average_response_time']:.2f} 秒。\n"
        else:
            summary += "- ⚠️ 在此次测试配置下，未观察到明显的漏洞利用迹象。可能需要调整参数（如增加并发数、延长测试时间）或目标本身已具备防护。\n"
        
        summary += f"\n原始日志片段（共 {len(results['evidence_log'])} 条）:\n"
        for log in results['evidence_log'][:5]:  # 只显示前5条
            summary += f"  {log}\n"
        if len(results['evidence_log']) > 5:
            summary += f"  ... 以及 {len(results['evidence_log']) - 5} 条更多记录。\n"
        
        summary += f"\n总执行时间: {time.time() - start_time:.2f} 秒"
        return summary + "\n" + result_text
    
    async def _slowloris_attack(self, target_url: str, duration: int, concurrency: int, results: Dict[str, Any]) -> str:
        """模拟慢速HTTP攻击（Slowloris）。"""
        async def slow_connection(session, conn_id):
            try:
                # 发起一个请求并缓慢发送头部
                response = await session.get(target_url, timeout=aiohttp.ClientTimeout(total=30))
                results['successful_responses'] += 1
                results['evidence_log'].append(f"连接 {conn_id}: 正常响应 {response.status}")
                await response.text()  # 消费响应体
            except asyncio.TimeoutError:
                results['timeouts'] += 1
                results['evidence_log'].append(f"连接 {conn_id}: 超时（服务器可能被占用）")
            except Exception as e:
                results['failed_responses'] += 1
                results['evidence_log'].append(f"连接 {conn_id}: 错误 {type(e).__name__}")
        
        connector = aiohttp.TCPConnector(limit=concurrency)
        timeout = aiohttp.ClientTimeout(total=duration + 10)
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            tasks = []
            for i in range(concurrency):
                task = asyncio.create_task(slow_connection(session, i))
                tasks.append(task)
            
            # 运行指定时长
            await asyncio.sleep(duration)
            # 取消所有任务
            for task in tasks:
                task.cancel()
            # 等待取消完成
            await asyncio.gather(*tasks, return_exceptions=True)
        
        results['requests_sent'] = concurrency
        return f"慢速攻击模拟完成。连接数：{concurrency}。"
    
    async def _resource_drain_attack(self, target_url: str, duration: int, concurrency: int, results: Dict[str, Any]) -> str:
        """模拟高并发请求以耗尽服务器资源。"""
        request_times = []
        
        async def make_request(session, req_id):
            start = time.time()
            try:
                response = await session.get(target_url)
                elapsed = time.time() - start
                request_times.append(elapsed)
                results['successful_responses'] += 1
                results['evidence_log'].append(f"请求 {req_id}: 成功，耗时 {elapsed:.2f}s，状态 {response.status}")
                await response.text()
            except asyncio.TimeoutError:
                results['timeouts'] += 1
                results['evidence_log'].append(f"请求 {req_id}: 超时")
            except Exception as e:
                results['failed_responses'] += 1
                results['evidence_log'].append(f"请求 {req_id}: 错误 {type(e).__name__}")
        
        connector = aiohttp.TCPConnector(limit=concurrency)
        timeout = aiohttp.ClientTimeout(total=10)
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            end_time = time.time() + duration
            request_id = 0
            while time.time() < end_time:
                tasks = []
                for _ in range(min(concurrency, 10)):  # 每批最多10个请求
                    task = asyncio.create_task(make_request(session, request_id))
                    tasks.append(task)
                    request_id += 1
                results['requests_sent'] += len(tasks)
                await asyncio.gather(*tasks, return_exceptions=True)
                await asyncio.sleep(0.1)  # 短暂间隔
        
        if request_times:
            results['average_response_time'] = sum(request_times) / len(request_times)
        return f"资源耗尽攻击模拟完成。总请求数：{results['requests_sent']}。"